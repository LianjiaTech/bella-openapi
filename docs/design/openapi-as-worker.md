# openapi作为bella-queue Worker - 设计文档

## 1. 概述

openapi作为 bella-queue Worker 的一个具体实现，通过充分利用渠道闲时余量来处理排队任务，基于实时容量指标动态调整任务消费，在不影响在线流量的前提下最大化渠道利用率。

### 目标

- 能够较准确评估渠道的实时负载,基于负载容量动态调整消费任务
## 2. 设计

### 主流程

WorkerManager 作为核心协调组件，负责管理 Worker 生命周期和任务执行流程：

#### 2.1 流程概述

1. **Worker 初始化**
   - 定期（每10分钟）扫描可用渠道，再次刷新 Worker 列表（剔除不可用、非queue_mode为pull的渠道，新增符合条件的渠道）
   - 为每个渠道创建对应的 Worker 实例

2. **Worker 启动**
   - 启动 Worker 线程池
   - 开始轮询队列任务（每5秒一次）

3. **任务执行轮询循环**
   - **容量检查**：评估渠道容量
   - **条件执行**：仅在有足够容量时调用 `worker.takeAndRun(take)`
   - **批量处理**：通过 do-while 循环持续获取任务直到队列为空
   - **委托执行**：任务最终委托给具体 Channel 处理

#### 2.2 决策流程

```
┌─────────────────┐
│   定时轮询(5s)   │
└─────────┬───────┘
          │
          ▼
┌─────────────────┐      ┌─────────────────┐
│   容量评估       │─────▶│  剩余容量≥70%?  │
│hasEnoughCapacity│      └─────────┬───────┘
└─────────────────┘                │
                                   │
                    ┌──────────────┼──────────────┐
                    │ 是           │ 否           │
                    ▼              ▼              ▼
          ┌─────────────────┐  ┌─────────────────┐
          │   批量获取任务   │  │   跳过本轮      │
          │  takeAndRun()   │  │  等待下次轮询   │
          └─────────┬───────┘  └─────────────────┘
                    │
                    ▼
          ┌─────────────────┐
          │  委托Channel执行 │
          └─────────┬───────┘
                    │
                    ▼
          ┌─────────────────┐
          │ 记录RPM指标     │
          │(所有请求通用)    │
          └─────────┬───────┘
                    │
                    ▼
          ┌─────────────────┐
          │ 更新EMA统计     │
          │ (Redis Lua)     │
          └─────────────────┘
```

### 组件交互

```
┌─────────────────┐
│  WorkerManager  │ ──── 轮询调度(5s)
│                 │ ──── 容量检查
│                 │ ──── 任务委托
└─────────┬───────┘        
          │                
          │ hasEnoughCapacity()
          ▼                
┌──────────────────────────────┐
│   ChannelIdleDetector        │ ──── RPM统计
│                              │ ──── EMA计算  
│                              │ ──── 阈值学习
└──────────────┬───────────────┘
               │
               │ Lua脚本执行
               ▼
┌──────────────────────────────┐
│        Redis 存储            │ ──── 滑动窗口
│                              │ ──── 历史记录
│                              │ ──── 实时指标
└──────────────────────────────┘
```



### 基于RPM的渠道负载评估

通过实时追踪渠道RPM并结合渠道最大承载能力,动态评估渠道当前负载水平,为Worker任务消费决策提供依据。

#### 1. RPM统计与基于EMA平滑处理

每次请求处理开始时(包括在线流量和Worker任务),都会记录渠道的RPM并通过EMA算法计算平滑负载情况。

**滑动窗口计数**

- 使用60秒(1分钟)为单位的滑动窗口
- 根据平均响应时间计算请求占用时长,在对应的多个分钟窗口中计数
- 例如: 90秒响应时间会在当前分钟和下一分钟窗口中各+1

**EMA平滑处理**

- **历史窗口初始化**: 首次请求时预填充10个零值条目("timestamp:0"),为EMA计算提供稳定的零基线
- **维护历史记录**: 最多保存10条RPM历史记录(时间戳:RPM值)
- **智能记录策略**: 仅在RPM变化≥15%或间隔≥120秒时更新历史记录
- **EMA计算流程**: 对历史记录应用时间衰减(半衰期180秒) → 指数移动平均(α=0.18)
- **快速计算模式**: 未达到记录条件时,使用衰减EMA与当前RPM加权(30%当前+70%衰减EMA)
- **数据保护**: 避免瞬时流量峰值和陈旧数据影响负载评估准确性

**记录示例**:

```
场景0: 首次请求初始化
  当前时间戳: 1634567890, 当前RPM: 80
  历史记录: 不存在 (Redis key不存在)
  
  初始化操作:
    - 预填充10个零值条目: ["1634567890:0", "1634567890:0", ...]
    - EMA计算基于零基线 = 0 rpm (初始衰减后全为0)
    - 添加首条真实记录: "1634567890:80"

场景1: 需要更新历史(RPM变化≥15%)
  当前时间: 10:30:45, 平均响应时间: 90秒
  当前RPM: 150, 上次记录RPM: 120 (变化25%)

  滑动窗口更新:
    - minute_window:channel-123:1030 += 1
    - minute_window:channel-123:1031 += 1

  历史记录(时间:RPM):
    [(10:20:45, 120), (10:22:30, 115), (10:24:15, 118), ...]

  应用时间衰减后EMA计算:
    衰减后历史: [114.2, 111.8, 116.5, ...]  (根据时间差应用衰减)
    EMA: 0.18 × 116.5 + 0.82 × 114.2 + ... = 135.8 rpm

  更新历史: 添加 (10:30:45, 150) 到列表

场景2: 不需要更新历史(RPM变化<15%)
  当前时间: 10:31:00, 当前RPM: 128
  上次EMA: 135.8 (15秒前)

  快速计算:
    衰减EMA = 135.8 × 0.5^(15/180) = 128.3 rpm
    调整EMA = 0.3 × 128 + 0.7 × 128.3 = 128.2 rpm
```

#### 2. 计算渠道最大RPM阈值

系统通过自动学习机制确定渠道的最大承载RPM。

**自学习触发条件**

当渠道出现以下情况时,系统判定渠道达到承载上限:

- **429状态码**: 供应商返回限流错误(直接触发)
- **503状态码**: 服务不可用错误(通过错误率间接触发)
- **高错误率**: 在最近60秒内,错误率超过配置阈值且完成请求数≥最小阈值

**阈值记录机制**

当渠道被标记为不可用时:

1. 记录当前时刻的RPM值(最近60秒的完成请求数)作为该渠道的最大RPM阈值
2. 存储到Redis: `bella-openapi-channel-metrics:{channelCode}:rpm_threshold`
3. 有效期: 24小时
4. 本地Guava Cache缓存5分钟,避免频繁访问Redis

**自学习示例**:

```
场景1: 429限流学习
  时间: 14:30:00
  渠道状态: 收到429响应
  当前RPM: 485 (最近60秒完成了485个请求)

  系统操作:
    - 标记渠道不可用(过期时间根据配置)
    - 记录阈值: rpm_threshold = 485 (24小时有效)
    - 后续Worker将以485作为该渠道的最大承载能力

场景2: 高错误率学习
  时间: 15:45:00
  渠道状态: 错误率65% (完成100,错误65)
  配置阈值: 错误率>60%, 最小完成数≥50
  当前RPM: 100

  系统操作:
    - 判定渠道达到承载上限
    - 记录阈值: rpm_threshold = 100 (24小时有效)
    - 标记渠道暂时不可用

场景3: 阈值动态调整
  第1天 14:00: 因429学习到阈值=450
  第1天 18:00: 因429学习到阈值=520 (覆盖之前的450)
  第2天 10:00: 因429学习到阈值=380 (可能渠道配额降低)

  系统会持续学习并更新阈值,适应渠道配额的变化
```

#### 3. 余量评估
##### 3.1 评估流程
1. **可用性校验**：检查渠道是否处于可用状态
2. **指标获取**：从本地缓存读取 EMA RPM 和最大 RPM 阈值
3. **时间衰减**：应用指数衰减函数处理ema历史数据（半衰期 180s）
4. **容量计算**：评估当前负载占比和剩余处理能力

##### 3.2 核心算法

**衰减公式**：

```
衰减后EMA = 原始EMA × 0.5^(时间差/180)
```

**容量计算**：

```
当前负载率 = 衰减后EMA / 渠道最大RPM
剩余容量率 = 1 - 当前负载率
消费决策 = 剩余容量率 ≥ 阈值（默认 70%）
```

##### 3.3 案例分析

| 场景 | 渠道 | 最大RPM | 原始EMA | 时间差 | 衰减系数 | 衰减后EMA | 负载率 | 剩余容量 | 决策 | 说明 |
|-----|------|---------|---------|--------|----------|-----------|--------|----------|------|------|
| 高负载保护 | gpt-4-turbo | 200 | 118.5 | 15s | 0.972 | 111.7 | 55.8% | 44.2% | 暂停消费 | 避免过载，保护渠道稳定性 |
| 低负载利用 | claude-3-sonnet | 300 | 45.2 | 10s | 0.981 | 43.5 | 14.5% | 85.5% | 继续消费 | 充分利用剩余容量处理排队任务 |
| 衰减恢复 | gpt-3.5-turbo | 150 | 120 | 360s | 0.25 | 30.0 | 20.0% | 80.0% | 继续消费 | 历史高负载经衰减后快速恢复 |

**计算公式示例**：
```
衰减系数 = 0.5^(时间差/180)
衰减后EMA = 原始EMA × 衰减系数
负载率 = 衰减后EMA / 最大RPM × 100%
剩余容量 = 100% - 负载率
决策规则 = 剩余容量 ≥ 70% ? 继续消费 : 暂停消费
```

**关键特性**：

- **动态调节**：基于实时负载自动调整消费策略
- **时间感知**：历史数据权重随时间指数递减
- **保护机制**：高负载时主动减少消费，防止系统过载
- **快速恢复**：负载降低后能及时恢复正常消费
